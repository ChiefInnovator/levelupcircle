<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level-Up Circle Generator</title>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Level-Up Circle Generator">
    <meta property="og:description" content="Create beautiful circular diagrams to visualize your goals, projects, or focus areas. Customize colors, labels, and glow effects.">
    <meta property="og:image" content="https://chiefinnovator.github.io/levelupcircle/preview.png">
    <meta property="og:url" content="https://chiefinnovator.github.io/levelupcircle/levelup-circle-generator.html">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Level-Up Circle Generator">
    <meta name="twitter:description" content="Create beautiful circular diagrams to visualize your goals, projects, or focus areas.">
    <meta name="twitter:image" content="https://chiefinnovator.github.io/levelupcircle/preview.png">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
        }
        
        .controls {
            background: #1a1a1a;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }
        
        .preview {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            padding: 20px;
            min-height: 0;
        }
        
        canvas {
            background: #000;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            aspect-ratio: 1;
            display: block;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            font-weight: 500;
            color: #b0b0b0;
        }
        
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 8px 12px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #39FF14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.3);
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            vertical-align: middle;
            cursor: pointer;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 8px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button.secondary {
            background: #2a2a2a;
            border: 1px solid #444;
        }
        
        button.secondary:hover {
            background: #3a3a3a;
            box-shadow: 0 3px 10px rgba(255, 255, 255, 0.1);
        }
        
        button.export {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            font-size: 16px;
            padding: 12px;
            margin-top: 12px;
        }
        
        .point-list {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        
        .point-item {
            display: grid;
            grid-template-columns: 30px 1fr 50px 32px;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 6px;
        }
        
        .point-index {
            color: #888;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }
        
        .point-label-input {
            padding: 6px 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }
        
        .point-delete {
            width: 28px;
            height: 28px;
            padding: 0;
            margin: 0;
            background: transparent;
            border: 1px solid #555;
            border-radius: 4px;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .point-delete:hover {
            background: #f5576c;
            border-color: #f5576c;
            color: #fff;
            transform: none;
            box-shadow: 0 0 8px rgba(245, 87, 108, 0.4);
        }
        
        .point-delete:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .point-delete:disabled:hover {
            background: transparent;
            border-color: #555;
            color: #888;
            box-shadow: none;
        }
        
        .add-point-btn {
            width: 100%;
            margin-top: 12px;
            padding: 10px;
            background: transparent;
            border: 2px dashed #444;
            border-radius: 6px;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .add-point-btn:hover {
            border-color: #39FF14;
            color: #39FF14;
            background: rgba(57, 255, 20, 0.1);
            transform: none;
            box-shadow: none;
        }
        
        .add-point-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .add-point-btn:disabled:hover {
            border-color: #444;
            color: #888;
            background: transparent;
        }
        
        /* Collapsible Sections */
        .collapsible-section {
            margin-bottom: 16px;
        }
        
        .collapsible-section summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            list-style: none;
            transition: all 0.2s ease;
        }
        
        .collapsible-section summary::-webkit-details-marker {
            display: none;
        }
        
        .collapsible-section summary::after {
            content: '‚ñº';
            font-size: 10px;
            transition: transform 0.2s ease;
        }
        
        .collapsible-section[open] summary::after {
            transform: rotate(180deg);
        }
        
        .collapsible-section summary:hover {
            background: #333;
            border-color: #555;
            color: #ccc;
        }
        
        .collapsible-section[open] summary {
            border-radius: 6px 6px 0 0;
            border-bottom: none;
        }
        
        .collapsible-content {
            padding: 12px;
            background: #222;
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 6px 6px;
        }
        
        .collapsible-content .control-group:last-child {
            margin-bottom: 0;
        }
        
        .section-label {
            margin-top: 16px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="color"] {
            width: 100%;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #1a1a1a;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 20px;
        }
        
        h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #fff;
        }
        
        .divider {
            height: 1px;
            background: #333;
            margin: 20px 0;
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        
        .toast {
            background: #2a2a2a;
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateX(120%);
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
            max-width: 300px;
            font-size: 14px;
        }
        
        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .toast.success {
            border-left: 4px solid #39FF14;
        }
        
        .toast.success .toast-icon {
            color: #39FF14;
        }
        
        .toast.error {
            border-left: 4px solid #f5576c;
        }
        
        .toast.error .toast-icon {
            color: #f5576c;
        }
        
        .toast.info {
            border-left: 4px solid #667eea;
        }
        
        .toast.info .toast-icon {
            color: #667eea;
        }
        
        .toast-icon {
            font-size: 16px;
        }
        
        .toast-message {
            flex: 1;
        }
        
        @media (max-width: 600px) {
            .toast-container {
                bottom: 80px;
                right: 10px;
                left: 10px;
            }
            
            .toast {
                max-width: none;
            }
        }
        
        /* Floating Share Bar */
        .floating-share-bar {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 50;
        }
        
        .share-btn {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            margin: 0;
            padding: 0;
        }
        
        .share-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        .share-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .share-btn.facebook {
            background: #1877F2;
            color: white;
        }
        
        .share-btn.twitter {
            background: #000;
            color: white;
            border: 1px solid #555;
        }
        
        .share-btn.twitter:hover {
            border-color: #888;
        }
        
        .share-btn.copy-link {
            background: #2a2a2a;
            color: #39FF14;
            border: 1px solid #444;
        }
        
        .share-btn.copy-link:hover {
            background: #3a3a3a;
            border-color: #39FF14;
        }
        
        .share-btn.fullscreen {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
        }
        
        .share-btn.fullscreen:hover {
            background: #3a3a3a;
            border-color: #888;
        }
        
        /* Fullscreen Mode */
        body.fullscreen-mode {
            overflow: hidden;
        }
        
        body.fullscreen-mode .container {
            display: block;
        }
        
        body.fullscreen-mode .controls,
        body.fullscreen-mode .mobile-toggle {
            display: none !important;
        }
        
        body.fullscreen-mode .floating-share-bar {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        body.fullscreen-mode .preview {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        body.fullscreen-mode canvas {
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
        }
        
        /* Fullscreen button active state */
        body.fullscreen-mode .share-btn.fullscreen {
            background: #39FF14;
            color: #000;
            border-color: #39FF14;
        }
        
        body.fullscreen-mode .share-btn.fullscreen:hover {
            background: #32d912;
            border-color: #32d912;
        }
        
        /* Mobile Toggle Button */
        .mobile-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            transition: all 0.3s ease;
            margin: 0;
            padding: 0;
        }
        
        .mobile-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        /* Scroll indicator for controls */
        .controls {
            position: relative;
        }
        
        .scroll-indicator {
            display: none;
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to top, #1a1a1a 0%, transparent 100%);
            pointer-events: none;
            margin-top: -40px;
        }
        
        .scroll-indicator::after {
            content: '‚Üì Scroll for more';
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .scroll-indicator.hidden {
            opacity: 0;
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 900px) {
            body {
                height: auto;
                overflow: auto;
            }
            
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                height: auto;
                min-height: 100vh;
            }
            
            .controls {
                max-height: 40vh;
                border-right: none;
                border-bottom: 1px solid #333;
                transition: max-height 0.3s ease;
            }
            
            .controls.collapsed {
                max-height: 60px;
                overflow: hidden;
            }
            
            .controls.collapsed > *:not(h1) {
                opacity: 0;
                pointer-events: none;
            }
            
            .controls.expanded {
                max-height: 70vh;
            }
            
            .preview {
                min-height: 55vh;
                padding: 10px;
            }
            
            .mobile-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .scroll-indicator {
                display: block;
            }
        }
        
        @media (max-width: 600px) {
            .controls {
                padding: 12px;
                max-height: 35vh;
            }
            
            .controls.expanded {
                max-height: 65vh;
            }
            
            .preview {
                min-height: 60vh;
            }
            
            .button-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            
            h1 {
                font-size: 18px;
                margin-bottom: 12px;
            }
            
            h2 {
                font-size: 14px;
            }
            
            .control-group {
                margin-bottom: 10px;
            }
            
            label {
                font-size: 12px;
                margin-bottom: 4px;
            }
            
            input[type="text"],
            input[type="number"],
            select {
                padding: 6px 10px;
                font-size: 13px;
            }
            
            button {
                padding: 8px 10px;
                font-size: 12px;
            }
            
            button.export {
                padding: 10px;
                font-size: 13px;
            }
            
            .point-item {
                grid-template-columns: 22px 1fr 40px 26px;
                gap: 4px;
                padding: 5px;
                margin-bottom: 6px;
            }
            
            .point-label-input {
                padding: 4px 6px;
                font-size: 11px;
            }
            
            .point-delete {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }
            
            input[type="color"] {
                height: 26px;
            }
            
            .mobile-toggle {
                width: 50px;
                height: 50px;
                font-size: 20px;
                bottom: 15px;
                right: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>
    <div class="container">
        <div class="controls" id="controls">
            <h1 onclick="toggleMobileControls()">üéØ Level-Up Circle</h1>
            
            <div class="control-group">
                <label for="title">Title</label>
                <input type="text" id="title" value="Level-Up Circle">
            </div>
            
            <div class="control-group">
                <label for="theme">Image Theme</label>
                <select id="theme">
                    <option value="dark">Dark (Black Background)</option>
                    <option value="light">Light (White Background)</option>
                </select>
            </div>
            
            <details class="collapsible-section">
                <summary>Advanced Settings</summary>
                <div class="collapsible-content">
                    <div class="control-group">
                        <label for="points">Number of Points (1-36)</label>
                        <input type="number" id="points" min="1" max="36" value="8">
                    </div>
                    
                    <div class="control-group">
                        <label for="exportSize">Export Size</label>
                        <select id="exportSize">
                            <option value="1080">1080√ó1080</option>
                            <option value="2048">2048√ó2048</option>
                            <option value="3840" selected>3840√ó3840</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="pointSize">Point Size</label>
                        <input type="number" id="pointSize" min="1" max="60" value="14">
                    </div>
                    
                    <div class="control-group">
                        <label for="labelOffset">Label Spacing (0-100px from points)</label>
                        <input type="number" id="labelOffset" min="0" max="100" value="35">
                    </div>
                    
                    <div class="control-group">
                        <label for="labelFontSize">Label Font Size (8-32px)</label>
                        <input type="number" id="labelFontSize" min="8" max="32" value="16">
                    </div>
                    
                    <div class="control-group">
                        <label for="titleFontSize">Title Font Size (16-48px)</label>
                        <input type="number" id="titleFontSize" min="16" max="48" value="28">
                    </div>
                </div>
            </details>
            
            <div class="section-label">Glow Effects</div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="neonGlowTitle" checked>
                    <span>Neon Glow Title</span>
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="neonGlowPoints" checked>
                    <span>Neon Glow Points</span>
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="neonGlowLabels" checked>
                    <span>Neon Glow Labels</span>
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="neonGlowCircle" checked>
                    <span>Neon Glow Circle</span>
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="neonGlowConnections" checked>
                    <span>Neon Glow Connections</span>
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showConnections" checked>
                    <span>Show Connection Lines</span>
                </label>
            </div>
            
            <div class="divider"></div>
            
            <div class="button-grid">
                <button class="secondary" onclick="randomizeColors()" title="Generate bright colors in ROYGBIV order. Alternates between golden angle and equal spacing.">üé® Random Colors</button>
                <button class="secondary" onclick="loadExample()">üìã Load Example</button>
                <button class="secondary" onclick="saveState()">üíæ Save State</button>
                <button class="secondary" onclick="clearState()">üóëÔ∏è Clear State</button>
            </div>
            
            <button class="secondary" onclick="redraw()" style="width: 100%; margin-top: 8px;">üîÑ Redraw</button>
            <button class="export" onclick="exportPNG()">üì∏ Export PNG</button>
            
            <div class="point-list">
                <h2>Point Configuration</h2>
                <div id="pointList"></div>
                <button class="add-point-btn" id="addPointBtn" onclick="addPoint()" title="Add a new point (max 36)">
                    ‚ûï Add Point
                </button>
            </div>
            <div class="scroll-indicator" id="scrollIndicator"></div>
        </div>
        
        <button class="mobile-toggle" id="mobileToggle" onclick="toggleMobileControls()" title="Toggle Settings">‚öôÔ∏è</button>
        
        <div class="preview">
            <div class="floating-share-bar">
                <button class="share-btn copy-link" onclick="shareLink()" title="Copy Share Link">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>
                </button>
                <button class="share-btn twitter" onclick="shareToTwitter()" title="Share to X/Twitter">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                </button>
                <button class="share-btn facebook" onclick="shareToFacebook()" title="Share to Facebook">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>
                </button>
                <button class="share-btn fullscreen" onclick="toggleFullscreen()" title="Toggle Fullscreen">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                </button>
            </div>
            <canvas id="canvas" role="img" aria-label="Level-Up Circle visualization"></canvas>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================================
        // Bright Non-Repeating Color Sequence Algorithm
        // ============================================================
        // Generates N bright, visually distinct colors that:
        // 1. Start at a random hue on the color wheel
        // 2. Step forward in ROYGBIV order (increasing hue)
        // 3. Maintain high saturation and optimal lightness for vibrancy
        // 4. Ensure no adjacent colors are identical
        // 5. Support two spacing strategies:
        //    - Equal: 360¬∞/N spacing for even distribution
        //    - Golden: 137.507764¬∞ golden angle for optimal visual separation
        // ============================================================
        
        function hslToHex(h, s, l) {
            // Convert HSL to RGB then to hex
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r = 0, g = 0, b = 0;
            
            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }
            
            // Convert to 0-255 range
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            
            // Convert to hex
            const toHex = (n) => n.toString(16).padStart(2, '0');
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }
        
        function generateBrightColors(n, options = {}) {
            // Handle edge cases
            if (n <= 0) return { colors: [], hslValues: [] };
            
            // Default options
            const spacing = options.spacing || 'equal';
            const saturation = options.saturation || 0.90;  // High saturation for vibrant colors
            const lightness = options.lightness || 0.50;    // 50% lightness for maximum vibrancy
            const seed = options.seed;
            
            // Use seed for reproducibility if provided
            let startHue;
            if (seed !== undefined) {
                // Simple seeded random
                const x = Math.sin(seed) * 10000;
                startHue = (x - Math.floor(x)) * 360;
            } else {
                startHue = Math.random() * 360;
            }
            
            // Calculate hue step based on spacing strategy
            let hueStep;
            if (spacing === 'golden') {
                hueStep = 137.507764; // Golden angle in degrees
            } else {
                // Equal spacing - handles edge cases
                // N=1: step doesn't matter
                // N=2: gives 180¬∞ (opposite colors)
                // N>2: evenly distributed
                hueStep = n > 1 ? 360 / n : 0;
            }
            
            // Generate colors
            const colors = [];
            const hslValues = [];
            
            for (let i = 0; i < n; i++) {
                let hue = (startHue + i * hueStep) % 360;
                
                // Generate hex color
                let hex = hslToHex(hue, saturation, lightness);
                
                // Check for adjacent duplicates (including nudging if needed)
                if (i > 0 && colors[i - 1] === hex) {
                    // Nudge hue to avoid duplicate
                    let attempts = 0;
                    const maxAttempts = 10;
                    
                    while (colors[i - 1] === hex && attempts < maxAttempts) {
                        hue = (hue + 2) % 360; // Nudge by 2 degrees
                        hex = hslToHex(hue, saturation, lightness);
                        attempts++;
                    }
                }
                
                colors.push(hex);
                hslValues.push({ h: hue, s: saturation, l: lightness });
            }
            
            return {
                colors,
                hslValues
            };
        }
        
        const defaultLabels = ['MILL5', 'Card Game', 'Webinars', 'Casual Apps', 'Inventing Fire with AI', 'Rich Crane', 'Xmas Store', 'Purdue Course'];
        
        let state = {
            title: 'Level-Up Circle',
            numPoints: 8,
            exportSize: 3840,
            theme: 'dark',                // 'dark' or 'light'
            neonGlowTitle: true,          // Glow for title
            neonGlowPoints: true,         // Glow for points
            neonGlowLabels: true,         // Glow for labels
            neonGlowCircle: true,         // Glow for outer circle
            neonGlowConnections: true,    // Glow for connection lines
            showConnections: true,
            pointSize: 14,
            labelOffset: 35,
            labelFontSize: 16,
            titleFontSize: 28,
            points: []
        };
        
        // Debounce utility for performance
        function debounce(fn, delay) {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn(...args), delay);
            };
        }
        
        function smartWrapLabel(text, ctx, maxWidth) {
            // Remove any existing \n for consistent processing
            text = text.replace(/\\n/g, ' ').trim();
            
            // Measure text width
            const fullWidth = ctx.measureText(text).width;
            
            // Short labels that fit comfortably should stay single line
            // Use 80% of max width as threshold for keeping single line
            if (fullWidth <= maxWidth * 0.8) {
                return [text];
            }
            
            // Look for natural break points with connecting words
            // Keep the connector with the second part for better readability
            const connectingWords = [' with ', ' and ', ' of ', ' for ', ' in ', ' at ', ' on ', ' to ', ' by ', ' from '];
            for (const connector of connectingWords) {
                const lowerText = text.toLowerCase();
                if (lowerText.includes(connector)) {
                    const index = lowerText.indexOf(connector);
                    const firstPart = text.slice(0, index).trim();
                    // Keep connector with second part
                    const secondPart = text.slice(index + 1).trim(); // +1 to keep the space, making "with AI" not "withAI"
                    
                    // Check if both parts fit within max width
                    const firstWidth = ctx.measureText(firstPart).width;
                    const secondWidth = ctx.measureText(secondPart).width;
                    
                    if (firstWidth <= maxWidth && secondWidth <= maxWidth) {
                        // Prefer this split if both parts are reasonably balanced
                        // or if it creates a natural semantic break
                        return [firstPart, secondPart];
                    }
                }
            }
            
            // For two-word phrases, always split between words
            const words = text.split(' ');
            if (words.length === 2) {
                const firstWidth = ctx.measureText(words[0]).width;
                const secondWidth = ctx.measureText(words[1]).width;
                
                // Even if they could fit on one line, split two-word phrases for better balance
                if (firstWidth <= maxWidth && secondWidth <= maxWidth) {
                    return [words[0], words[1]];
                }
            }
            
            // For three-word phrases, try different combinations
            if (words.length === 3) {
                // Try 1+2 split
                const option1First = words[0];
                const option1Second = words.slice(1).join(' ');
                
                // Try 2+1 split
                const option2First = words.slice(0, 2).join(' ');
                const option2Second = words[2];
                
                // Check which split is more balanced
                const opt1FirstWidth = ctx.measureText(option1First).width;
                const opt1SecondWidth = ctx.measureText(option1Second).width;
                const opt2FirstWidth = ctx.measureText(option2First).width;
                const opt2SecondWidth = ctx.measureText(option2Second).width;
                
                // Choose the split that fits and is most balanced
                if (opt1FirstWidth <= maxWidth && opt1SecondWidth <= maxWidth) {
                    const opt1Diff = Math.abs(opt1FirstWidth - opt1SecondWidth);
                    if (opt2FirstWidth <= maxWidth && opt2SecondWidth <= maxWidth) {
                        const opt2Diff = Math.abs(opt2FirstWidth - opt2SecondWidth);
                        if (opt2Diff < opt1Diff) {
                            return [option2First, option2Second];
                        }
                    }
                    return [option1First, option1Second];
                } else if (opt2FirstWidth <= maxWidth && opt2SecondWidth <= maxWidth) {
                    return [option2First, option2Second];
                }
            }
            
            // For longer phrases, find the most balanced split point
            if (words.length > 3) {
                let bestSplit = Math.floor(words.length / 2);
                let bestBalance = Infinity;
                
                for (let i = 1; i < words.length; i++) {
                    const firstLine = words.slice(0, i).join(' ');
                    const secondLine = words.slice(i).join(' ');
                    
                    const firstWidth = ctx.measureText(firstLine).width;
                    const secondWidth = ctx.measureText(secondLine).width;
                    
                    // Both parts must fit
                    if (firstWidth <= maxWidth && secondWidth <= maxWidth) {
                        // Calculate balance (prefer similar line lengths)
                        const balance = Math.abs(firstWidth - secondWidth);
                        if (balance < bestBalance) {
                            bestBalance = balance;
                            bestSplit = i;
                        }
                    }
                }
                
                const firstLine = words.slice(0, bestSplit).join(' ');
                const secondLine = words.slice(bestSplit).join(' ');
                
                if (ctx.measureText(firstLine).width <= maxWidth && 
                    ctx.measureText(secondLine).width <= maxWidth) {
                    return [firstLine, secondLine];
                }
            }
            
            // If no good split found, try to fit in one line if possible
            if (fullWidth <= maxWidth) {
                return [text];
            }
            
            // Last resort: use standard wrapping
            return wrapText(ctx, text, maxWidth);
        }
        
        function wrapText(ctx, text, maxWidth) {
            // Handle explicit line breaks first
            const segments = text.split('\\n');
            const allLines = [];
            
            for (const segment of segments) {
                const words = segment.split(' ');
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine) {
                        allLines.push(currentLine);
                        currentLine = word;
                    } else if (metrics.width > maxWidth && !currentLine) {
                        // Single word exceeds max width - force break it
                        let tempWord = word;
                        while (tempWord.length > 0) {
                            let charCount = tempWord.length;
                            while (charCount > 0 && ctx.measureText(tempWord.substring(0, charCount)).width > maxWidth) {
                                charCount--;
                            }
                            if (charCount === 0) charCount = 1; // At least one character
                            allLines.push(tempWord.substring(0, charCount));
                            tempWord = tempWord.substring(charCount);
                        }
                    } else {
                        currentLine = testLine;
                    }
                }
                
                if (currentLine) {
                    allLines.push(currentLine);
                }
            }
            
            return allLines;
        }
        
        function calculateBoundingBox(ctx, lines, lineHeight, padding) {
            let maxWidth = 0;
            for (const line of lines) {
                const width = ctx.measureText(line).width;
                if (width > maxWidth) maxWidth = width;
            }
            
            const textWidth = maxWidth;
            const textHeight = lines.length * lineHeight;
            
            return {
                width: textWidth + 2 * padding,
                height: textHeight + 2 * padding,
                textWidth,
                textHeight
            };
        }
        
        // Legacy wrapper function - now just calls smartWrapLabel
        function wrapLabel(text) {
            // This function is kept for backward compatibility
            // but now uses the smart wrapping algorithm
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `700 16px Arial, sans-serif`;
            const lines = smartWrapLabel(text, ctx, 220);
            return lines.join('\\n');
        }
        
        function initializePoints(count) {
            // Generate bright colors for initial points
            const colorResult = generateBrightColors(count, {
                spacing: 'equal',
                saturation: 0.85,
                lightness: 0.50,
                seed: 42  // Fixed seed for consistent initial colors
            });
            
            const points = [];
            for (let i = 0; i < count; i++) {
                points.push({
                    label: defaultLabels[i] || `Point ${i + 1}`,
                    color: colorResult.colors[i]
                });
            }
            return points;
        }
        
        function updatePointList() {
            const container = document.getElementById('pointList');
            container.innerHTML = '';
            
            // Validate number of points
            state.numPoints = Math.max(1, Math.min(36, state.numPoints));
            
            const currentCount = state.points.length;
            const targetCount = state.numPoints;
            
            if (targetCount > currentCount) {
                // Generate colors for new points using the algorithm
                const newColors = generateBrightColors(targetCount - currentCount, {
                    spacing: 'golden',
                    saturation: 0.85,
                    lightness: 0.50
                });
                
                for (let i = currentCount; i < targetCount; i++) {
                    state.points.push({
                        label: `Point ${i + 1}`,
                        color: newColors.colors[i - currentCount]
                    });
                }
            } else if (targetCount < currentCount) {
                state.points = state.points.slice(0, targetCount);
            }
            
            state.points.forEach((point, index) => {
                const item = document.createElement('div');
                item.className = 'point-item';
                const isOnlyPoint = state.numPoints <= 1;
                item.innerHTML = `
                    <div class="point-index">${String(index + 1).padStart(2, '0')}</div>
                    <input type="text" class="point-label-input" value="${point.label}" 
                           data-index="${index}" onchange="updatePointLabel(${index}, this.value)">
                    <input type="color" value="${point.color}" 
                           data-index="${index}" onchange="updatePointColor(${index}, this.value)">
                    <button class="point-delete" onclick="deletePoint(${index})" 
                            title="Delete point" ${isOnlyPoint ? 'disabled' : ''}>‚úï</button>
                `;
                container.appendChild(item);
            });
            
            // Update add button state
            updateAddButtonState();
            
            redraw();
        }
        
        function updatePointLabel(index, value) {
            // Validate index
            if (index >= 0 && index < state.points.length) {
                // Ensure label is not empty
                state.points[index].label = value || `Point ${index + 1}`;
                redraw();
            }
        }
        
        function updatePointColor(index, value) {
            // Validate index and color format
            if (index >= 0 && index < state.points.length) {
                // Validate hex color format
                const hexRegex = /^#[0-9A-Fa-f]{6}$/;
                if (hexRegex.test(value)) {
                    state.points[index].color = value;
                } else {
                    // Fallback to a default color if invalid
                    state.points[index].color = '#39FF14';
                }
                redraw();
            }
        }
        
        function deletePoint(index) {
            // Don't allow deleting if only 1 point remains
            if (state.numPoints <= 1) return;
            
            // Validate index
            if (index >= 0 && index < state.points.length) {
                // Remove the point
                state.points.splice(index, 1);
                state.numPoints = state.points.length;
                
                // Update the points input field
                document.getElementById('points').value = state.numPoints;
                
                // Refresh the UI
                updatePointList();
            }
        }
        
        function addPoint() {
            // Don't allow adding if already at max (36)
            if (state.numPoints >= 36) return;
            
            // Generate a color for the new point
            const newColor = generateBrightColors(1, {
                spacing: 'golden',
                saturation: 0.85,
                lightness: 0.50
            });
            
            // Add the new point
            state.points.push({
                label: `Point ${state.numPoints + 1}`,
                color: newColor.colors[0]
            });
            state.numPoints = state.points.length;
            
            // Update the points input field
            document.getElementById('points').value = state.numPoints;
            
            // Update the add button state
            updateAddButtonState();
            
            // Refresh the UI
            updatePointList();
        }
        
        function updateAddButtonState() {
            const addBtn = document.getElementById('addPointBtn');
            if (addBtn) {
                addBtn.disabled = state.numPoints >= 36;
            }
        }
        
        // Track the current color spacing mode
        let colorSpacingMode = 'golden';
        
        function randomizeColors() {
            // Toggle between golden and equal spacing for variety
            colorSpacingMode = colorSpacingMode === 'golden' ? 'equal' : 'golden';
            
            // Generate bright, visually distinct colors using the algorithm
            // This ensures colors follow ROYGBIV order around the color wheel
            // with no adjacent duplicates and high visual contrast
            const result = generateBrightColors(state.numPoints, {
                spacing: colorSpacingMode,  // Alternates between golden and equal
                saturation: 0.85,   // High saturation for vibrant, neon-like colors
                lightness: 0.50     // 50% lightness for maximum color vibrancy
            });
            
            // Apply the generated colors to points
            state.points.forEach((point, index) => {
                point.color = result.colors[index];
            });
            
            updatePointList();
            
            // Log for debugging (optional)
            console.log(`Generated ${state.numPoints} colors using ${colorSpacingMode} spacing`);
        }
        
        function loadExample() {
            state = {
                title: 'Level-Up Circle',
                numPoints: 8,
                exportSize: 3840,
                theme: 'dark',
                neonGlowTitle: true,
                neonGlowPoints: true,
                neonGlowLabels: true,
                neonGlowCircle: true,
                neonGlowConnections: true,
                showConnections: true,
                pointSize: 14,
                labelOffset: 35,
                labelFontSize: 16,
                titleFontSize: 28,
                points: initializePoints(8)
            };
            
            document.getElementById('title').value = state.title;
            document.getElementById('theme').value = state.theme;
            document.getElementById('points').value = state.numPoints;
            document.getElementById('exportSize').value = state.exportSize;
            document.getElementById('neonGlowTitle').checked = state.neonGlowTitle;
            document.getElementById('neonGlowPoints').checked = state.neonGlowPoints;
            document.getElementById('neonGlowLabels').checked = state.neonGlowLabels;
            document.getElementById('neonGlowCircle').checked = state.neonGlowCircle;
            document.getElementById('neonGlowConnections').checked = state.neonGlowConnections;
            document.getElementById('showConnections').checked = state.showConnections;
            document.getElementById('pointSize').value = state.pointSize;
            document.getElementById('labelOffset').value = state.labelOffset;
            document.getElementById('labelFontSize').value = state.labelFontSize;
            document.getElementById('titleFontSize').value = state.titleFontSize;
            
            updatePointList();
        }
        
        // Toast notification system
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úì',
                error: '‚úï',
                info: '‚Ñπ'
            };
            
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${message}</span>
            `;
            
            container.appendChild(toast);
            
            // Trigger animation
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Auto-save function (silent, no toast)
        function autoSave() {
            try {
                localStorage.setItem('levelUpCircleState', JSON.stringify(state));
            } catch (e) {
                console.error('Auto-save failed:', e);
            }
        }
        
        // Debounced auto-save to avoid too frequent writes
        const debouncedAutoSave = debounce(autoSave, 500);
        
        function saveState() {
            try {
                localStorage.setItem('levelUpCircleState', JSON.stringify(state));
                showToast('State saved successfully!', 'success');
            } catch (e) {
                console.error('Failed to save state:', e);
                showToast('Failed to save state. Storage may be full.', 'error');
            }
        }
        
        function clearState() {
            try {
                localStorage.removeItem('levelUpCircleState');
            } catch (e) {
                console.error('Failed to clear state:', e);
            }
            // Reset to default state with all glow settings enabled
            state.neonGlowTitle = true;
            state.neonGlowPoints = true;
            state.neonGlowLabels = true;
            state.neonGlowCircle = true;
            state.neonGlowConnections = true;
            loadExample();
            showToast('State cleared and example loaded!', 'success');
        }
        
        // Deep link functions - New compressed format using lz-string
        function encodeStateToURL() {
            // Build state object with all settings
            const stateObj = {
                t: state.title,
                n: state.numPoints,
                es: state.exportSize,
                th: state.theme,
                ps: state.pointSize,
                lo: state.labelOffset,
                fs: state.labelFontSize,
                tfs: state.titleFontSize,
                gt: state.neonGlowTitle ? 1 : 0,
                gp: state.neonGlowPoints ? 1 : 0,
                gl: state.neonGlowLabels ? 1 : 0,
                gc: state.neonGlowCircle ? 1 : 0,
                gn: state.neonGlowConnections ? 1 : 0,
                sc: state.showConnections ? 1 : 0,
                // Points as array of [label, color] pairs (color without #)
                p: state.points.map(pt => [pt.label, pt.color.replace('#', '')])
            };
            
            // Stringify, compress, and encode for URL
            const json = JSON.stringify(stateObj);
            const compressed = LZString.compressToEncodedURIComponent(json);
            return `s=${compressed}`;
        }
        
        // Decode from new compressed format
        function decodeStateFromCompressed(compressedString) {
            try {
                const json = LZString.decompressFromEncodedURIComponent(compressedString);
                if (!json) return null;
                
                const obj = JSON.parse(json);
                
                const newState = {
                    title: obj.t || 'Level-Up Circle',
                    numPoints: parseInt(obj.n) || 8,
                    exportSize: parseInt(obj.es) || 3840,
                    theme: obj.th || 'dark',
                    pointSize: parseInt(obj.ps) || 14,
                    labelOffset: parseInt(obj.lo) || 35,
                    labelFontSize: parseInt(obj.fs) || 16,
                    titleFontSize: parseInt(obj.tfs) || 28,
                    neonGlowTitle: obj.gt !== 0,
                    neonGlowPoints: obj.gp !== 0,
                    neonGlowLabels: obj.gl !== 0,
                    neonGlowCircle: obj.gc !== 0,
                    neonGlowConnections: obj.gn !== 0,
                    showConnections: obj.sc !== 0,
                    points: []
                };
                
                // Decode points from array format
                if (obj.p && Array.isArray(obj.p)) {
                    newState.points = obj.p.map((pt, index) => ({
                        label: pt[0] || `Point ${index + 1}`,
                        color: `#${pt[1] || '39FF14'}`
                    }));
                    newState.numPoints = newState.points.length;
                }
                
                // Validate
                return validateState(newState);
            } catch (e) {
                console.error('Failed to decode compressed state:', e);
                return null;
            }
        }
        
        // Legacy decoder for backwards compatibility with old URL format
        function decodeStateFromLegacyURL(searchParams) {
            try {
                const newState = {
                    title: searchParams.get('t') || 'Level-Up Circle',
                    numPoints: parseInt(searchParams.get('n')) || 8,
                    exportSize: parseInt(searchParams.get('es')) || 3840,
                    theme: searchParams.get('th') || 'dark',
                    pointSize: parseInt(searchParams.get('ps')) || 14,
                    labelOffset: parseInt(searchParams.get('lo')) || 35,
                    labelFontSize: parseInt(searchParams.get('fs')) || 16,
                    titleFontSize: parseInt(searchParams.get('tfs')) || 28,
                    neonGlowTitle: searchParams.get('gt') !== '0',
                    neonGlowPoints: searchParams.get('gp') !== '0',
                    neonGlowLabels: searchParams.get('gl') !== '0',
                    neonGlowCircle: searchParams.get('gc') !== '0',
                    neonGlowConnections: searchParams.get('gn') !== '0',
                    showConnections: searchParams.get('sc') !== '0',
                    points: []
                };
                
                // Decode points from legacy format: label|color,label|color,...
                const pointsData = searchParams.get('p');
                if (pointsData) {
                    const pointStrings = pointsData.split(',');
                    newState.points = pointStrings.map((ps, index) => {
                        const [label, color] = ps.split('|');
                        return {
                            label: decodeURIComponent(label) || `Point ${index + 1}`,
                            color: `#${color || '39FF14'}`
                        };
                    });
                    newState.numPoints = newState.points.length;
                }
                
                // Validate
                return validateState(newState);
            } catch (e) {
                console.error('Failed to decode legacy URL state:', e);
                return null;
            }
        }
        
        // Common validation for decoded state
        function validateState(newState) {
            newState.numPoints = Math.max(1, Math.min(36, newState.numPoints));
            newState.pointSize = Math.max(1, Math.min(60, newState.pointSize));
            newState.labelOffset = Math.max(0, Math.min(100, newState.labelOffset));
            newState.labelFontSize = Math.max(8, Math.min(32, newState.labelFontSize));
            newState.titleFontSize = Math.max(16, Math.min(48, newState.titleFontSize || 28));
            newState.exportSize = [1080, 2048, 3840].includes(newState.exportSize) ? newState.exportSize : 3840;
            newState.theme = ['dark', 'light'].includes(newState.theme) ? newState.theme : 'dark';
            
            // If no points decoded, initialize them
            if (newState.points.length === 0) {
                newState.points = initializePoints(newState.numPoints);
            }
            
            return newState;
        }
        
        function shareLink() {
            const shareURL = getShareURL();
            
            // Try to copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareURL)
                    .then(() => {
                        showToast('Share link copied to clipboard!', 'success');
                    })
                    .catch(() => {
                        // Fallback: show URL in prompt
                        prompt('Copy this share link:', shareURL);
                    });
            } else {
                // Fallback for older browsers
                prompt('Copy this share link:', shareURL);
            }
        }
        
        function getShareURL() {
            const encoded = encodeStateToURL();
            const baseURL = window.location.origin + window.location.pathname;
            const isFullscreen = document.body.classList.contains('fullscreen-mode');
            return isFullscreen ? `${baseURL}?${encoded}&fs=1` : `${baseURL}?${encoded}`;
        }
        
        function isLocalEnvironment() {
            const hostname = window.location.hostname;
            return hostname === 'localhost' || 
                   hostname === '127.0.0.1' || 
                   hostname === '' || 
                   window.location.protocol === 'file:';
        }
        
        function shareToFacebook() {
            if (isLocalEnvironment()) {
                showToast('Facebook sharing requires a public URL. Deploy to GitHub Pages first, or use "Copy Share Link" instead.', 'error');
                return;
            }
            const shareURL = getShareURL();
            const facebookURL = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareURL)}`;
            window.open(facebookURL, '_blank', 'width=600,height=400');
            showToast('Opening Facebook share dialog...', 'info');
        }
        
        function shareToTwitter() {
            if (isLocalEnvironment()) {
                showToast('Twitter sharing requires a public URL. Deploy to GitHub Pages first, or use "Copy Share Link" instead.', 'error');
                return;
            }
            const shareURL = getShareURL();
            const text = `Check out my Level-Up Circle: ${state.title}`;
            const twitterURL = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(shareURL)}`;
            window.open(twitterURL, '_blank', 'width=600,height=400');
            showToast('Opening X/Twitter share dialog...', 'info');
        }
        
        function toggleFullscreen() {
            const isFullscreen = document.body.classList.contains('fullscreen-mode');
            
            if (isFullscreen) {
                // Exit fullscreen
                document.body.classList.remove('fullscreen-mode');
                
                // Clear URL params
                window.history.replaceState({}, '', window.location.pathname);
            } else {
                // Enter fullscreen
                document.body.classList.add('fullscreen-mode');
                
                // Update URL to include state and fullscreen parameter
                const url = new URL(window.location.href);
                const compressed = LZString.compressToEncodedURIComponent(JSON.stringify(state));
                url.searchParams.set('s', compressed);
                url.searchParams.set('fs', '1');
                window.history.replaceState({}, '', url.toString());
            }
            
            // Trigger a redraw to ensure canvas is properly sized
            setTimeout(() => redraw(), 100);
        }
        
        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const isFullscreen = urlParams.get('fs') === '1';
            
            // First, check for new compressed format (s parameter)
            if (urlParams.has('s')) {
                const compressed = urlParams.get('s');
                const urlState = decodeStateFromCompressed(compressed);
                if (urlState) {
                    state = urlState;
                    applyStateToUI();
                    
                    // If fullscreen mode, enter it and keep URL as-is
                    if (isFullscreen) {
                        document.body.classList.add('fullscreen-mode');
                        // Trigger redraw after fullscreen mode is applied
                        setTimeout(() => redraw(), 100);
                    } else {
                        // Clear URL params after loading (cleaner URL)
                        window.history.replaceState({}, '', window.location.pathname);
                        showToast('Loaded shared configuration!', 'success');
                    }
                    return true;
                }
            }
            
            // Fall back to legacy format for backwards compatibility
            if (urlParams.has('t') || urlParams.has('p')) {
                const urlState = decodeStateFromLegacyURL(urlParams);
                if (urlState) {
                    state = urlState;
                    applyStateToUI();
                    
                    // Clear URL params after loading (cleaner URL)
                    window.history.replaceState({}, '', window.location.pathname);
                    
                    showToast('Loaded shared configuration!', 'success');
                    return true;
                }
            }
            return false;
        }
        
        // Helper function to apply state to UI elements
        function applyStateToUI() {
            document.getElementById('title').value = state.title;
            document.getElementById('theme').value = state.theme;
            document.getElementById('points').value = state.numPoints;
            document.getElementById('exportSize').value = state.exportSize;
            document.getElementById('neonGlowTitle').checked = state.neonGlowTitle;
            document.getElementById('neonGlowPoints').checked = state.neonGlowPoints;
            document.getElementById('neonGlowLabels').checked = state.neonGlowLabels;
            document.getElementById('neonGlowCircle').checked = state.neonGlowCircle;
            document.getElementById('neonGlowConnections').checked = state.neonGlowConnections;
            document.getElementById('showConnections').checked = state.showConnections;
            document.getElementById('pointSize').value = state.pointSize;
            document.getElementById('labelOffset').value = state.labelOffset;
            document.getElementById('labelFontSize').value = state.labelFontSize;
            document.getElementById('titleFontSize').value = state.titleFontSize;
            
            updatePointList();
        }
        
        function loadState() {
            try {
                const saved = localStorage.getItem('levelUpCircleState');
                if (saved) {
                    state = JSON.parse(saved);
                    
                    // Handle backward compatibility - migrate old properties
                    if (state.neonGlow !== undefined && state.neonGlowPoints === undefined) {
                        state.neonGlowPoints = state.neonGlow;
                        state.neonGlowLabels = state.neonGlow;
                        state.neonGlowCircle = state.neonGlow;
                        state.neonGlowConnections = state.neonGlow;
                        delete state.neonGlow; // Clean up old property
                    }
                    // Migrate from combined neonGlowPointsLabels to separate properties
                    if (state.neonGlowPointsLabels !== undefined && state.neonGlowPoints === undefined) {
                        state.neonGlowPoints = state.neonGlowPointsLabels;
                        state.neonGlowLabels = state.neonGlowPointsLabels;
                        delete state.neonGlowPointsLabels;
                    }
                    // Migrate from combined neonGlowLines to separate properties
                    if (state.neonGlowLines !== undefined && state.neonGlowCircle === undefined) {
                        state.neonGlowCircle = state.neonGlowLines;
                        state.neonGlowConnections = state.neonGlowLines;
                        delete state.neonGlowLines;
                    }
                    
                    // Validate loaded state
                    state.numPoints = Math.max(1, Math.min(36, state.numPoints || 8));
                    state.pointSize = Math.max(1, Math.min(60, state.pointSize || 14));
                    state.labelOffset = Math.max(0, Math.min(100, state.labelOffset || 35));
                    state.labelFontSize = Math.max(8, Math.min(32, state.labelFontSize || 16));
                    state.titleFontSize = Math.max(16, Math.min(48, state.titleFontSize || 28));
                    state.exportSize = [1080, 2048, 3840].includes(state.exportSize) ? state.exportSize : 3840;
                    state.title = state.title || 'Level-Up Circle';
                    state.theme = ['dark', 'light'].includes(state.theme) ? state.theme : 'dark';
                    state.neonGlowTitle = state.neonGlowTitle !== undefined ? state.neonGlowTitle : true;
                    state.neonGlowPoints = state.neonGlowPoints !== undefined ? state.neonGlowPoints : true;
                    state.neonGlowLabels = state.neonGlowLabels !== undefined ? state.neonGlowLabels : true;
                    state.neonGlowCircle = state.neonGlowCircle !== undefined ? state.neonGlowCircle : true;
                    state.neonGlowConnections = state.neonGlowConnections !== undefined ? state.neonGlowConnections : true;
                    
                    // Update UI with validated values
                    document.getElementById('title').value = state.title;
                    document.getElementById('theme').value = state.theme;
                    document.getElementById('points').value = state.numPoints;
                    document.getElementById('exportSize').value = state.exportSize;
                    document.getElementById('neonGlowTitle').checked = state.neonGlowTitle;
                    document.getElementById('neonGlowPoints').checked = state.neonGlowPoints;
                    document.getElementById('neonGlowLabels').checked = state.neonGlowLabels;
                    document.getElementById('neonGlowCircle').checked = state.neonGlowCircle;
                    document.getElementById('neonGlowConnections').checked = state.neonGlowConnections;
                    document.getElementById('showConnections').checked = state.showConnections;
                    document.getElementById('pointSize').value = state.pointSize;
                    document.getElementById('labelOffset').value = state.labelOffset;
                    document.getElementById('labelFontSize').value = state.labelFontSize;
                    document.getElementById('titleFontSize').value = state.titleFontSize;
                    updatePointList();
                } else {
                    loadExample();
                }
            } catch (e) {
                console.error('Failed to load state:', e);
                loadExample();
            }
        }
        
        function drawCircle(ctx, size, isExport = false) {
            // Theme colors
            const isDark = state.theme === 'dark';
            const bgColor = isDark ? '#000' : '#fff';
            const titleColor = isDark ? '#fff' : '#000';
            const circleColor = isDark ? (state.neonGlowCircle ? '#aaa' : '#888') : (state.neonGlowCircle ? '#555' : '#666');
            const connectionColor = isDark ? (state.neonGlowConnections ? '#777' : '#666') : (state.neonGlowConnections ? '#888' : '#999');
            const glowColor = isDark ? '#fff' : '#000';
            const labelOutlineColor = isDark ? '#000' : '#fff';
            
            // Clear canvas with background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, size, size);
            
            // Calculate dimensions - adaptive padding for different screen sizes
            // Use more padding on smaller screens to prevent label clipping
            const basePadding = size * 0.26; // 26% padding to accommodate wrapped labels
            const minPadding = 60; // Minimum padding in pixels for very small screens
            const padding = Math.max(basePadding, minPadding);
            
            const centerX = size / 2;
            const centerY = size / 2;
            const circleRadius = (size - padding * 2) / 2;
            
            // Adaptive scale factor based on canvas size
            // Reference size is 800px - scale proportionally for other sizes
            const referenceSize = 800;
            const displayScaleFactor = size / referenceSize;
            const exportScaleFactor = isExport ? size / canvas.width : 1;
            const scaleFactor = isExport ? exportScaleFactor : Math.max(0.5, Math.min(1.5, displayScaleFactor));
            
            const pointRadius = state.pointSize * scaleFactor;
            const labelOffsetScaled = state.labelOffset * scaleFactor;
            
            // Font settings - scale with canvas size but with min/max limits
            const baseFontSize = state.labelFontSize || 16;
            const baseTitleSize = state.titleFontSize || 28;
            const fontSize = Math.max(8, Math.min(32, baseFontSize * scaleFactor));
            const titleFontSize = Math.max(16, Math.min(48, baseTitleSize * scaleFactor));
            const lineHeight = fontSize * 1.2; // Proportional line height
            const labelPadding = Math.max(4, 6 * scaleFactor); // Padding for bounding box
            const maxLabelWidth = Math.min(180 * scaleFactor, size * 0.22); // Slightly reduced for mobile
            
            // Draw title with proper spacing
            ctx.save();
            ctx.fillStyle = titleColor;
            ctx.font = `700 ${titleFontSize}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const titleY = padding * 0.45;
            
            if (state.neonGlowTitle) {
                ctx.strokeStyle = labelOutlineColor;
                ctx.lineWidth = 4 * scaleFactor;
                ctx.strokeText(state.title, centerX, titleY);
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 12 * scaleFactor;
                ctx.fillText(state.title, centerX, titleY);
            } else {
                ctx.fillText(state.title, centerX, titleY);
            }
            ctx.restore();
            
            // Draw outer ring
            ctx.save();
            ctx.strokeStyle = circleColor;
            ctx.lineWidth = state.neonGlowCircle ? 2 * scaleFactor : 1 * scaleFactor;
            if (state.neonGlowCircle) {
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 8 * scaleFactor;
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            
            // Calculate point positions on the circle
            const positions = [];
            for (let i = 0; i < state.numPoints; i++) {
                // Start from top and go clockwise
                const angle = (i * 2 * Math.PI / state.numPoints) - Math.PI / 2;
                const x = centerX + circleRadius * Math.cos(angle);
                const y = centerY + circleRadius * Math.sin(angle);
                positions.push({ x, y, angle });
            }
            
            // Draw connection lines if enabled
            if (state.showConnections) {
                ctx.save();
                ctx.strokeStyle = connectionColor;
                ctx.lineWidth = 1 * scaleFactor;
                if (state.neonGlowConnections) {
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 3 * scaleFactor;
                }
                
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        ctx.beginPath();
                        ctx.moveTo(positions[i].x, positions[i].y);
                        ctx.lineTo(positions[j].x, positions[j].y);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            }
            
            // Draw points and labels with radial placement
            positions.forEach((pos, index) => {
                const point = state.points[index];
                
                // Adaptive point size for small screens
                const adaptivePointRadius = Math.max(6, pointRadius);
                
                // Draw the point
                ctx.save();
                ctx.fillStyle = point.color;
                ctx.strokeStyle = labelOutlineColor;
                ctx.lineWidth = Math.max(1, 2 * scaleFactor);
                if (state.neonGlowPoints) {
                    ctx.shadowColor = point.color;
                    ctx.shadowBlur = Math.max(8, 15 * scaleFactor);
                }
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, adaptivePointRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // LABEL POSITIONING - Using effective outer circle (circle + point radius)
                // This ensures labels are positioned from the outer edge of points, not the circle line
                
                // Prepare for label text measurement
                ctx.save();
                ctx.font = `700 ${fontSize}px Arial, sans-serif`; // 700 weight for bold
                
                // Wrap text to fit max width
                const lines = wrapText(ctx, point.label, maxLabelWidth);
                
                // Calculate bounding box
                const bbox = calculateBoundingBox(ctx, lines, lineHeight, labelPadding);
                
                // Step 4: Box placement along the radial
                // The inner edge of the box should be exactly LABEL_OFFSET from the OUTER edge of points
                // Effective outer circle radius = circleRadius + adaptivePointRadius
                // So box center is at: (R + adaptivePointRadius) + LABEL_OFFSET + boxH/2
                // Add extra offset based on font size increase from base (16px)
                // When font size is larger, labels need more space from the circle
                // Also add extra offset based on point size increase from base (14px)
                const baseFontSizeScaled = 16 * scaleFactor;
                const basePointSizeScaled = 14 * scaleFactor;
                const fontSizeExtra = Math.max(0, (fontSize - baseFontSizeScaled) * 0.5);
                const pointSizeExtra = Math.max(0, (adaptivePointRadius - basePointSizeScaled) * 0.5);
                const adaptiveLabelOffset = Math.max(15 * scaleFactor, labelOffsetScaled) + fontSizeExtra + pointSizeExtra;
                const effectiveOuterRadius = circleRadius + adaptivePointRadius;
                const boxCenterDistance = effectiveOuterRadius + adaptiveLabelOffset + bbox.height / 2;
                const boxCenterX = centerX + Math.cos(pos.angle) * boxCenterDistance;
                const boxCenterY = centerY + Math.sin(pos.angle) * boxCenterDistance;
                
                // Determine text alignment and box position based on angle (quadrant)
                let textAlign = 'center';
                let boxLeft, boxTop;
                const cosAngle = Math.cos(pos.angle);
                
                if (cosAngle > 0.15) {
                    // Right side - left align text, box grows to the right
                    textAlign = 'left';
                    boxLeft = boxCenterX - bbox.width / 2;
                } else if (cosAngle < -0.15) {
                    // Left side - right align text, box grows to the left
                    textAlign = 'right';
                    boxLeft = boxCenterX - bbox.width / 2;
                } else {
                    // Top/bottom - center align
                    textAlign = 'center';
                    boxLeft = boxCenterX - bbox.width / 2;
                }
                
                boxTop = boxCenterY - bbox.height / 2;
                
                // Step 5: Draw leader line from point edge to box edge
                ctx.save();
                ctx.strokeStyle = point.color;
                ctx.lineWidth = Math.max(0.5, 0.5 * scaleFactor);
                ctx.globalAlpha = 0.4;
                
                // Apply glow to leader lines if connections glow is enabled
                if (state.neonGlowConnections) {
                    ctx.shadowColor = point.color;
                    ctx.shadowBlur = Math.max(1, 2 * scaleFactor);
                }
                
                // Line starts just outside the point edge (using adaptivePointRadius)
                const lineStartRadius = circleRadius + adaptivePointRadius + 1 * scaleFactor;
                // Line ends just before the label box edge
                const lineEndRadius = boxCenterDistance - bbox.height / 2 - 1 * scaleFactor;
                
                ctx.beginPath();
                ctx.moveTo(
                    centerX + Math.cos(pos.angle) * lineStartRadius,
                    centerY + Math.sin(pos.angle) * lineStartRadius
                );
                ctx.lineTo(
                    centerX + Math.cos(pos.angle) * lineEndRadius,
                    centerY + Math.sin(pos.angle) * lineEndRadius
                );
                ctx.stroke();
                ctx.restore();
                
                // Step 6: Label rendering
                ctx.save();
                ctx.font = `700 ${fontSize}px Arial, sans-serif`; // 700 weight for bold
                ctx.textAlign = textAlign;
                ctx.textBaseline = 'middle';
                
                // Calculate text position within the box
                let textX;
                if (textAlign === 'left') {
                    textX = boxLeft + labelPadding;
                } else if (textAlign === 'right') {
                    textX = boxLeft + bbox.width - labelPadding;
                } else {
                    textX = boxLeft + bbox.width / 2;
                }
                
                // Render each line
                if (state.neonGlowLabels) {
                    // Outline for readability (opposite of background)
                    ctx.strokeStyle = labelOutlineColor;
                    ctx.lineWidth = 3 * scaleFactor;
                    lines.forEach((line, lineIndex) => {
                        const textY = boxTop + labelPadding + lineIndex * lineHeight + lineHeight / 2;
                        ctx.strokeText(line, textX, textY);
                    });
                    
                    // Glowing colored text
                    ctx.fillStyle = point.color;
                    ctx.shadowColor = point.color;
                    ctx.shadowBlur = 10 * scaleFactor;
                    lines.forEach((line, lineIndex) => {
                        const textY = boxTop + labelPadding + lineIndex * lineHeight + lineHeight / 2;
                        ctx.fillText(line, textX, textY);
                    });
                } else {
                    ctx.fillStyle = point.color;
                    lines.forEach((line, lineIndex) => {
                        const textY = boxTop + labelPadding + lineIndex * lineHeight + lineHeight / 2;
                        ctx.fillText(line, textX, textY);
                    });
                }
                ctx.restore();
            });
        }
        
        // Debounced redraw for resize events
        const debouncedRedraw = debounce(redraw, 50);
        
        function redraw() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const size = Math.min(rect.width - 40, rect.height - 40);
            canvas.width = size;
            canvas.height = size;
            drawCircle(ctx, size);
            
            // Update preview area background to match theme
            const preview = document.querySelector('.preview');
            if (state.theme === 'light') {
                preview.style.background = '#fff';
            } else {
                preview.style.background = '#000';
            }
            
            // Auto-save state on every redraw (debounced)
            debouncedAutoSave();
        }
        
        function exportPNG() {
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            const size = parseInt(state.exportSize);
            
            exportCanvas.width = size;
            exportCanvas.height = size;
            
            drawCircle(exportCtx, size, true);
            
            exportCanvas.toBlob(blob => {
                if (!blob) {
                    showToast('Failed to generate image.', 'error');
                    return;
                }
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `level-up-circle-${size}x${size}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showToast(`Exported ${size}√ó${size} PNG`, 'success');
            }, 'image/png');
        }
        
        // Event listeners with validation
        document.getElementById('title').addEventListener('input', (e) => {
            state.title = e.target.value || 'Level-Up Circle'; // Default if empty
            redraw();
        });
        
        document.getElementById('points').addEventListener('input', (e) => {
            let value = parseInt(e.target.value);
            
            // Validate range 1-36
            if (isNaN(value)) {
                value = 8; // Default
            } else if (value < 1) {
                value = 1;
                e.target.value = 1;
            } else if (value > 36) {
                value = 36;
                e.target.value = 36;
            }
            
            state.numPoints = value;
            updatePointList();
        });
        
        document.getElementById('exportSize').addEventListener('change', (e) => {
            const value = parseInt(e.target.value);
            // Validate export size is one of the allowed values
            if ([1080, 2048, 3840].includes(value)) {
                state.exportSize = value;
            } else {
                state.exportSize = 3840; // Default
                e.target.value = 3840;
            }
        });
        
        document.getElementById('theme').addEventListener('change', (e) => {
            state.theme = e.target.value;
            redraw();
        });
        
        document.getElementById('neonGlowTitle').addEventListener('change', (e) => {
            state.neonGlowTitle = e.target.checked;
            redraw();
        });
        
        document.getElementById('neonGlowPoints').addEventListener('change', (e) => {
            state.neonGlowPoints = e.target.checked;
            redraw();
        });
        
        document.getElementById('neonGlowLabels').addEventListener('change', (e) => {
            state.neonGlowLabels = e.target.checked;
            redraw();
        });
        
        document.getElementById('neonGlowCircle').addEventListener('change', (e) => {
            state.neonGlowCircle = e.target.checked;
            redraw();
        });
        
        document.getElementById('neonGlowConnections').addEventListener('change', (e) => {
            state.neonGlowConnections = e.target.checked;
            redraw();
        });
        
        document.getElementById('showConnections').addEventListener('change', (e) => {
            state.showConnections = e.target.checked;
            redraw();
        });
        
        document.getElementById('pointSize').addEventListener('input', (e) => {
            let value = parseInt(e.target.value);
            
            // Validate range 1-60
            if (isNaN(value)) {
                value = 14; // Default
            } else if (value < 1) {
                value = 1;
                e.target.value = 1;
            } else if (value > 60) {
                value = 60;
                e.target.value = 60;
            }
            
            state.pointSize = value;
            redraw();
        });
        
        document.getElementById('labelOffset').addEventListener('input', (e) => {
            let value = parseInt(e.target.value);
            
            // Validate range 0-100
            if (isNaN(value)) {
                value = 35; // Default
            } else if (value < 0) {
                value = 0;
                e.target.value = 0;
            } else if (value > 100) {
                value = 100;
                e.target.value = 100;
            }
            
            state.labelOffset = value;
            redraw();
        });
        
        document.getElementById('labelFontSize').addEventListener('input', (e) => {
            let value = parseInt(e.target.value);
            
            // Validate range 8-32
            if (isNaN(value)) {
                value = 16; // Default
            } else if (value < 8) {
                value = 8;
                e.target.value = 8;
            } else if (value > 32) {
                value = 32;
                e.target.value = 32;
            }
            
            state.labelFontSize = value;
            redraw();
        });
        
        document.getElementById('titleFontSize').addEventListener('input', (e) => {
            let value = parseInt(e.target.value);
            
            // Validate range 16-48
            if (isNaN(value)) {
                value = 28; // Default
            } else if (value < 16) {
                value = 16;
                e.target.value = 16;
            } else if (value > 48) {
                value = 48;
                e.target.value = 48;
            }
            
            state.titleFontSize = value;
            redraw();
        });
        
        // Add blur handlers to enforce limits when focus leaves the input
        document.getElementById('points').addEventListener('blur', (e) => {
            let value = parseInt(e.target.value);
            if (isNaN(value) || value < 1) {
                e.target.value = 1;
                state.numPoints = 1;
            } else if (value > 36) {
                e.target.value = 36;
                state.numPoints = 36;
            }
            updatePointList();
        });
        
        document.getElementById('pointSize').addEventListener('blur', (e) => {
            let value = parseInt(e.target.value);
            if (isNaN(value) || value < 1) {
                e.target.value = 1;
                state.pointSize = 1;
            } else if (value > 60) {
                e.target.value = 60;
                state.pointSize = 60;
            }
            redraw();
        });
        
        document.getElementById('labelOffset').addEventListener('blur', (e) => {
            let value = parseInt(e.target.value);
            if (isNaN(value) || value < 0) {
                e.target.value = 0;
                state.labelOffset = 0;
            } else if (value > 100) {
                e.target.value = 100;
                state.labelOffset = 100;
            }
            redraw();
        });
        
        document.getElementById('labelFontSize').addEventListener('blur', (e) => {
            let value = parseInt(e.target.value);
            if (isNaN(value) || value < 8) {
                e.target.value = 8;
                state.labelFontSize = 8;
            } else if (value > 32) {
                e.target.value = 32;
                state.labelFontSize = 32;
            }
            redraw();
        });
        
        document.getElementById('titleFontSize').addEventListener('blur', (e) => {
            let value = parseInt(e.target.value);
            if (isNaN(value) || value < 16) {
                e.target.value = 16;
                state.titleFontSize = 16;
            } else if (value > 48) {
                e.target.value = 48;
                state.titleFontSize = 48;
            }
            redraw();
        });
        
        // ResizeObserver for responsive canvas - use debounced version
        const resizeObserver = new ResizeObserver(() => {
            requestAnimationFrame(debouncedRedraw);
        });
        resizeObserver.observe(canvas.parentElement);
        
        // Mobile toggle functionality
        function toggleMobileControls() {
            const controls = document.getElementById('controls');
            const toggle = document.getElementById('mobileToggle');
            
            // Only toggle on mobile
            if (window.innerWidth > 900) return;
            
            if (controls.classList.contains('collapsed')) {
                controls.classList.remove('collapsed');
                controls.classList.add('expanded');
                toggle.textContent = '‚úï';
                toggle.title = 'Collapse Settings';
            } else if (controls.classList.contains('expanded')) {
                controls.classList.remove('expanded');
                controls.classList.add('collapsed');
                toggle.textContent = '‚öôÔ∏è';
                toggle.title = 'Expand Settings';
            } else {
                // Default state - collapse it
                controls.classList.add('collapsed');
                toggle.textContent = '‚öôÔ∏è';
                toggle.title = 'Expand Settings';
            }
        }
        
        // Scroll indicator visibility
        function updateScrollIndicator() {
            const controls = document.getElementById('controls');
            const indicator = document.getElementById('scrollIndicator');
            
            if (!indicator || window.innerWidth > 900) return;
            
            const isScrollable = controls.scrollHeight > controls.clientHeight;
            const isAtBottom = controls.scrollTop + controls.clientHeight >= controls.scrollHeight - 10;
            
            if (isScrollable && !isAtBottom) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }
        
        // Initialize mobile features
        function initMobileFeatures() {
            const controls = document.getElementById('controls');
            
            // Update scroll indicator on scroll
            controls.addEventListener('scroll', updateScrollIndicator);
            
            // Check on resize
            window.addEventListener('resize', () => {
                updateScrollIndicator();
                
                // Reset mobile state on desktop
                if (window.innerWidth > 900) {
                    controls.classList.remove('collapsed', 'expanded');
                    document.getElementById('mobileToggle').textContent = '‚öôÔ∏è';
                }
            });
            
            // Initial check
            setTimeout(updateScrollIndicator, 100);
        }
        
        // Initialize
        // Check for shared URL first, then fall back to localStorage
        if (!loadFromURL()) {
            loadState();
        }
        initMobileFeatures();
    </script>
</body>
</html>